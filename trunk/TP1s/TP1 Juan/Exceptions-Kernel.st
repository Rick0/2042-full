Object subclass: #Exception	instanceVariableNames: 'messageText tag signalContext handlerContext outerContext'	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!Exception commentStamp: '<historical>' prior: 0!This is the main class used to implement the exception handling system (EHS).  It plays two distinct roles:  that of the exception, and that of the exception handler.  More specifically, it implements the bulk of the protocols laid out in the ANSI specification - those protocol names are reflected in the message categories.Exception is an abstract class.  Instances should neither be created nor trapped.  In most cases, subclasses should inherit from Error or Notification rather than directly from Exception.In implementing this EHS, The Fourth Estate Inc. incorporated some ideas and code from Craig Latta's EHS.  His insights were crucial in allowing us to implement BlockContext>>valueUninterruptably (and by extension, #ensure: and #ifCurtailed:), and we imported the following methods with little or no modification:ContextPart>>terminateTo:ContextPart>>terminateMethodContext>>receiver:MethodContext>>answer:Thanks, Craig!!!!Exception methodsFor: '*SUnit' stamp: 'jp 3/17/2003 10:03'!sunitExitWith: aValue         self return: aValue! !!Exception methodsFor: 'exceptionbuilder' stamp: 'pnm 8/16/2000 15:23'!tag: t	"This message is not specified in the ANSI protocol, but that looks like an oversight because #tag is specified, and the spec states that the signaler may store the tag value."	tag := t! !!Exception methodsFor: 'exceptiondescription' stamp: 'pnm 8/16/2000 14:54'!tag	"Return an exception's tag value."	^tag == nil		ifTrue: [self messageText]		ifFalse: [tag]! !!Exception methodsFor: 'handling' stamp: 'ajh 2/1/2003 01:32'!isNested	"Determine whether the current exception handler is within the scope of another handler for the same exception."	^ handlerContext nextHandlerContext canHandleSignal: self! !!Exception methodsFor: 'handling' stamp: 'ajh 6/27/2003 22:13'!outer	"Evaluate the enclosing exception action and return to here instead of signal if it resumes (see #resumeUnchecked:)."	| prevOuterContext |	self isResumable ifTrue: [		prevOuterContext := outerContext.		outerContext := thisContext contextTag.	].	self pass.! !!Exception methodsFor: 'handling' stamp: 'ajh 2/1/2003 01:33'!pass	"Yield control to the enclosing exception action for the receiver."	handlerContext nextHandlerContext handleSignal: self! !!Exception methodsFor: 'handling' stamp: 'ajh 1/22/2003 23:04'!resignalAs: replacementException	"Signal an alternative exception in place of the receiver."	self resumeUnchecked: replacementException signal! !!Exception methodsFor: 'handling' stamp: 'StephaneDucasse 2/16/2010 14:02'!resume	"Return from the message that signaled the receiver."	self resume: self defaultResumeValue! !!Exception methodsFor: 'handling' stamp: 'ajh 6/27/2003 22:30'!resumeUnchecked: resumptionValue	"Return resumptionValue as the value of #signal, unless this was called after an #outer message, then return resumptionValue as the value of #outer."	| ctxt |	outerContext ifNil: [		signalContext return: resumptionValue	] ifNotNil: [		ctxt := outerContext.		outerContext := ctxt tempAt: 1. "prevOuterContext in #outer"		ctxt return: resumptionValue	].! !!Exception methodsFor: 'handling' stamp: 'ajh 1/13/2002 15:14'!resume: resumptionValue	"Return resumptionValue as the value of the signal message."	self isResumable ifFalse: [IllegalResumeAttempt signal].	self resumeUnchecked: resumptionValue! !!Exception methodsFor: 'handling' stamp: 'ajh 1/29/2003 13:36'!retry	"Abort an exception handler and re-evaluate its protected block."	handlerContext restart! !!Exception methodsFor: 'handling' stamp: 'ajh 1/29/2003 13:37'!retryUsing: alternativeBlock	"Abort an exception handler and evaluate a new block in place of the handler's protected block."	handlerContext restartWithNewReceiver: alternativeBlock! !!Exception methodsFor: 'handling' stamp: 'StephaneDucasse 2/16/2010 14:03'!return	"Return nil as the value of the block protected by the active exception handler."	self return: self defaultReturnValue! !!Exception methodsFor: 'handling' stamp: 'ajh 1/29/2003 13:37'!return: returnValue	"Return the argument as the value of the block protected by the active exception handler."	handlerContext return: returnValue! !!Exception methodsFor: 'handling' stamp: 'ajh 2/16/2003 17:37'!searchFrom: aContext	" Set the context where the handler search will start. "	signalContext := aContext contextTag! !!Exception methodsFor: 'printing' stamp: 'pnm 8/16/2000 14:53'!description	"Return a textual description of the exception."	| desc mt |	desc := self class name asString.	^(mt := self messageText) == nil		ifTrue: [desc]		ifFalse: [desc, ': ', mt]! !!Exception methodsFor: 'printing' stamp: 'StephaneDucasse 2/13/2010 12:18'!messageText	"Return an exception's message text."	^ messageText ifNil: [ String empty ]! !!Exception methodsFor: 'printing' stamp: 'ajh 9/30/2001 15:33'!printOn: stream	stream nextPutAll: self description! !!Exception methodsFor: 'printing' stamp: 'ajh 10/22/2001 14:24'!receiver	^ self signalerContext receiver! !!Exception methodsFor: 'printing' stamp: 'ar 6/28/2003 00:13'!signalerContext	"Find the first sender of signal(:)"	^ signalContext findContextSuchThat: [:ctxt |		(ctxt receiver == self or: [ctxt receiver == self class]) not]! !!Exception methodsFor: 'priv handling' stamp: 'ajh 9/30/2001 15:33'!defaultAction	"The default action taken if the exception is signaled."	self subclassResponsibility! !!Exception methodsFor: 'priv handling' stamp: 'StephaneDucasse 2/16/2010 14:01'!defaultResumeValue	"Answer the value that by default should be returned if the exception is resumed"	^nil! !!Exception methodsFor: 'priv handling' stamp: 'StephaneDucasse 2/16/2010 14:02'!defaultReturnValue	"Answer the value that by default should be returned if the exception is returned"	^nil! !!Exception methodsFor: 'priv handling' stamp: 'ajh 2/1/2003 00:58'!isResumable	"Determine whether an exception is resumable."	^ true! !!Exception methodsFor: 'priv handling' stamp: 'ajh 1/29/2003 13:44'!privHandlerContext: aContextTag	handlerContext := aContextTag! !!Exception methodsFor: 'signaling' stamp: 'ajh 9/30/2001 15:33'!messageText: signalerText	"Set an exception's message text."	messageText := signalerText! !!Exception methodsFor: 'signaling' stamp: 'ToonVerwaest 6/8/2010 10:06'!signal	"Ask ContextHandlers in the sender chain to handle this signal.  The default is to execute and return my defaultAction."	signalContext := thisContext contextTag.	^ signalContext nextHandlerContext handleSignal: self! !!Exception methodsFor: 'signaling' stamp: 'ajh 9/30/2001 20:13'!signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	self messageText: signalerText.	^ self signal! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Exception class	instanceVariableNames: ''!!Exception class methodsFor: '*ob-standard' stamp: 'lr 3/28/2009 15:56'!browserIcon	^ #exception! !!Exception class methodsFor: 'exceptioninstantiator' stamp: 'ajh 9/30/2001 21:54'!signal	"Signal the occurrence of an exceptional condition."	^ self new signal! !!Exception class methodsFor: 'exceptioninstantiator' stamp: 'ajh 9/30/2001 21:54'!signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	^ self new signal: signalerText! !!Exception class methodsFor: 'exceptionselector' stamp: 'ajh 9/30/2001 15:33'!, anotherException	"Create an exception set."	^ExceptionSet new		add: self;		add: anotherException;		yourself! !!Exception class methodsFor: 'exceptionselector' stamp: 'ajh 8/5/2003 11:33'!handles: exception	"Determine whether an exception handler will accept a signaled exception."	^ exception isKindOf: self! !Exception subclass: #UnhandledError	instanceVariableNames: 'exception'	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!UnhandledError methodsFor: 'as yet unclassified' stamp: 'ajh 9/4/2002 19:15'!exception	^ exception! !!UnhandledError methodsFor: 'as yet unclassified' stamp: 'ajh 9/4/2002 19:15'!exception: anError	exception := anError! !!UnhandledError methodsFor: 'priv handling' stamp: 'ar 9/27/2005 19:53'!defaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	^ToolSet debugError: exception.! !!UnhandledError methodsFor: 'priv handling' stamp: 'ajh 2/1/2003 00:56'!isResumable		^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnhandledError class	instanceVariableNames: ''!!UnhandledError class methodsFor: 'as yet unclassified' stamp: 'ajh 9/4/2002 19:17'!signalForException: anError	^ self new		exception: anError;		signal! !Exception subclass: #Abort	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!Abort methodsFor: 'as yet unclassified' stamp: 'ajh 3/24/2003 00:55'!defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	UnhandledError signalForException: self! !Exception subclass: #Notification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!Notification commentStamp: '<historical>' prior: 0!A Notification is an indication that something interesting has occurred.  If it is not handled, it will pass by without effect.!!Notification methodsFor: 'exceptiondescription' stamp: 'pnm 8/16/2000 15:04'!defaultAction	"No action is taken. The value nil is returned as the value of the message that signaled the exception."	^nil! !Notification subclass: #Warning	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!Warning commentStamp: '<historical>' prior: 0!A Warning is a Notification which by default should be brought to the attention of the user.!!Warning methodsFor: 'exceptiondescription' stamp: 'ar 9/27/2005 19:54'!defaultAction	"The user should be notified of the occurrence of an exceptional occurrence and given an option of continuing or aborting the computation. The description of the occurrence should include any text specified as the argument of the #signal: message."	ToolSet		debugContext: thisContext		label: 'Warning'		contents: self messageText, '\\Select Proceed to continue, or close this window to cancel the operation.' withCRs.	self resume.! !Warning subclass: #Deprecation	instanceVariableNames: 'methodReference explanationString deprecationDate versionString'	classVariableNames: 'Log RaiseWarning ShowWarning'	poolDictionaries: ''	category: 'Exceptions-Kernel'!!Deprecation commentStamp: 'dew 5/21/2003 17:46' prior: 0!This Warning is signalled by methods which are deprecated.The use of Object>>#deprecatedExplanation: aString and Object>>#deprecated: aBlock explanation: aString is recommended.Idiom: Imagine I want to deprecate the message #foo.foo	^ 'foo'I can replace it with:foo	self deprecatedExplanation: 'The method #foo was not good. Use Bar>>newFoo instead.'	^ 'foo'Or, for certain cases such as when #foo implements a primitive, #foo can be renamed to #fooDeprecated.fooDeprecated	^ <primitive>foo	^ self deprecated: [self fooDeprecated] explanation: 'The method #foo was not good. Use Bar>>newFoo instead.'!!Deprecation methodsFor: 'accessing' stamp: 'eem 7/3/2009 19:07'!deprecationDate	"Answer the value of deprecationDate"	^ deprecationDate! !!Deprecation methodsFor: 'accessing' stamp: 'eem 7/3/2009 19:07'!explanationString	"Answer the value of explanationString"	^ explanationString! !!Deprecation methodsFor: 'accessing' stamp: 'AndrewBlack 8/31/2009 03:15'!messageText	"Return an exception's message text."	^ 'The method ', methodReference stringVersion, ' has been deprecated.', explanationString! !!Deprecation methodsFor: 'accessing' stamp: 'eem 7/3/2009 19:07'!methodReference	"Answer the value of methodReference"	^ methodReference! !!Deprecation methodsFor: 'accessing' stamp: 'eem 7/3/2009 19:07'!versionString	"Answer the value of versionString"	^ versionString! !!Deprecation methodsFor: 'comparing' stamp: 'eem 7/3/2009 19:10'!= anObject	^self class == anObject class	  and: [methodReference = anObject methodReference	  and: [methodReference			ifNil: [explanationString = anObject explanationString]			ifNotNil: [true]]]! !!Deprecation methodsFor: 'comparing' stamp: 'eem 7/3/2009 19:08'!hash	^(methodReference ifNil: [explanationString]) hash! !!Deprecation methodsFor: 'handling' stamp: 'AlainPlantec 12/11/2009 10:09'!defaultAction	Log 		ifNotNil: [:log | log add: self].	self showWarning 		ifTrue: [Transcript nextPutAll: self messageText; cr; flush].	self raiseWarning 		ifTrue: [super defaultAction]! !!Deprecation methodsFor: 'initialize-release' stamp: 'eem 7/3/2009 18:57'!method: aCompiledMethod explanation: anExplanationString on: dateString in: aVersionString	methodReference := aCompiledMethod methodReference.	explanationString := anExplanationString.	deprecationDate := dateString.	versionString := aVersionString ! !!Deprecation methodsFor: 'settings' stamp: 'AlainPlantec 12/11/2009 10:08'!raiseWarning	^ self class raiseWarning! !!Deprecation methodsFor: 'settings' stamp: 'AlainPlantec 12/11/2009 10:08'!showWarning	^ self class showWarning! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Deprecation class	instanceVariableNames: ''!!Deprecation class methodsFor: 'instance creation' stamp: 'eem 7/3/2009 19:15'!method: aCompiledMethod explanation: anExplanationString on: dateString in: aVersionString	^self new method: aCompiledMethod explanation: anExplanationString on: dateString in: aVersionString! !!Deprecation class methodsFor: 'logging' stamp: 'eem 7/3/2009 19:13'!deprecationsWhile: aBlock	| oldLog result |	oldLog := Log.	Log := Set new.	aBlock value.	result := Log.	oldLog ifNotNil: [oldLog addAll: result].	Log := oldLog.	^result! !!Deprecation class methodsFor: 'settings' stamp: 'AlainPlantec 12/11/2009 10:06'!raiseWarning	^ RaiseWarning ifNil: [RaiseWarning := true]! !!Deprecation class methodsFor: 'settings' stamp: 'AlainPlantec 12/11/2009 10:06'!raiseWarning: aBoolean	RaiseWarning := aBoolean! !!Deprecation class methodsFor: 'settings' stamp: 'AlainPlantec 12/11/2009 10:07'!showWarning	^ ShowWarning ifNil: [ShowWarning := true]! !!Deprecation class methodsFor: 'settings' stamp: 'AlainPlantec 12/11/2009 10:07'!showWarning: aBoolean	ShowWarning := aBoolean! !Object subclass: #ExceptionSet	instanceVariableNames: 'exceptions'	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!ExceptionSet commentStamp: '<historical>' prior: 0!An ExceptionSet is a grouping of exception handlers which acts as a single handler.  Within the group, the most recently added handler will be the last handler found during a handler search (in the case where more than one handler in the group is capable of handling a given exception). !!ExceptionSet methodsFor: 'exceptionselector' stamp: 'tfei 6/4/1999 18:37'!, anException	"Return an exception set that contains the receiver and the argument exception. This is commonly used to specify a set of exception selectors for an exception handler."	self add: anException.	^self! !!ExceptionSet methodsFor: 'exceptionselector' stamp: 'pnm 8/16/2000 15:15'!handles: anException	"Determine whether an exception handler will accept a signaled exception."	exceptions do:		[:ex |		(ex handles: anException)			ifTrue: [^true]].	^false! !!ExceptionSet methodsFor: 'private' stamp: 'StephaneDucasse 5/6/2010 08:44'!add: anException	^ exceptions add: anException! !!ExceptionSet methodsFor: 'private' stamp: 'alain.plantec 5/28/2009 09:52'!initialize	super initialize.	exceptions := OrderedCollection new! !Exception subclass: #IllegalResumeAttempt	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!IllegalResumeAttempt commentStamp: '<historical>' prior: 0!This class is private to the EHS implementation.  An instance of it is signaled whenever an attempt is made to resume from an exception which answers false to #isResumable.!!IllegalResumeAttempt methodsFor: 'comment' stamp: 'ajh 9/4/2002 19:24'!defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	UnhandledError signalForException: self! !!IllegalResumeAttempt methodsFor: 'comment' stamp: 'ajh 2/1/2003 00:57'!isResumable		^ false! !!IllegalResumeAttempt methodsFor: 'comment' stamp: 'tfei 6/2/1999 14:59'!readMe	"Never handle this exception!!"! !Exception subclass: #Error	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!Error commentStamp: '<historical>' prior: 0!>From the ANSI standard:This protocol describes the behavior of instances of class Error. These are used to represent error conditions that prevent the normal continuation of processing. Actual error exceptions used by an application may be subclasses of this class.As Error is explicitly specified  to be subclassable, conforming implementations must implement its behavior in a non-fragile manner.Additional notes:Error>defaultAction uses an explicit test for the presence of the Debugger class to decide whether or not it is in development mode.  In the future, TFEI hopes to enhance the semantics of #defaultAction to improve support for pluggable default handlers.!!Error methodsFor: '*SUnit' stamp: 'NiallRoss 7/18/2010 11:59'!sunitAnnounce: aTestCase toResult: aTestResult	aTestResult addError: aTestCase.	self sunitExitWith: false.! !!Error methodsFor: 'exceptiondescription' stamp: 'ajh 9/4/2002 19:24'!defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	UnhandledError signalForException: self! !!Error methodsFor: 'private' stamp: 'ajh 2/1/2003 00:54'!isResumable	"Determine whether an exception is resumable."	^ false! !Error subclass: #MasDeUnAlgo42	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!MasDeUnAlgo42 commentStamp: '<historical>' prior: 0!MasDeUnAlgo42 se lanza cuando se trata de agregar más de un jugador.!Error subclass: #GuiaIncorrecto	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!Error subclass: #ErrorDeTipoItem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!ErrorDeTipoItem commentStamp: 'JuanDausa 5/7/2011 18:36' prior: 0!ErrorDeEquipo es lanzada si el tipo no coincide con los posibles.!Error subclass: #EnergiaAQuitarIncorrecta	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!Error subclass: #ErrorDeEquipo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!ErrorDeEquipo commentStamp: 'JuanDausa 5/7/2011 17:22' prior: 0!ErrorDeEquipo es lanzada si el equipo no coincide con los posibles.!Error subclass: #DuplicatedVariableError	instanceVariableNames: 'superclass variable'	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!DuplicatedVariableError methodsFor: 'accessing' stamp: 'Janniklaval 10/23/2010 13:06'!superclass        "The superclass in which the variable is defined"        ^superclass! !!DuplicatedVariableError methodsFor: 'accessing' stamp: 'Janniklaval 10/23/2010 13:06'!superclass: aSuperclass        "The superclass in which the variable is defined"        superclass := aSuperclass! !!DuplicatedVariableError methodsFor: 'accessing' stamp: 'Janniklaval 10/23/2010 13:06'!variable        "Name of the duplicate variable"        ^variable! !!DuplicatedVariableError methodsFor: 'accessing' stamp: 'Janniklaval 10/23/2010 13:07'!variable: aVariable        "Name of the duplicate variable"        variable := aVariable! !!DuplicatedVariableError methodsFor: 'testing' stamp: 'Janniklaval 10/23/2010 13:06'!isResumable        ^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DuplicatedVariableError class	instanceVariableNames: ''!Error subclass: #ErrorDeReferencias	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!ErrorDeReferencias commentStamp: '<historical>' prior: 0!Esto no sabemos por que sucede, pero debe detenerse el juego si esto pasa.!Error subclass: #OutOfMemory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!!OutOfMemory commentStamp: 'StephaneDucasse 12/18/2009 12:01' prior: 0!OutOfMemory is signaled when an allocation fails due to not having enough memory. Its default action signals the low-space semaphore.Originally suggested by A. Raab.!!OutOfMemory methodsFor: 'handling' stamp: 'StephaneDucasse 12/18/2009 11:57'!defaultAction	Smalltalk signalLowSpace.! !!OutOfMemory methodsFor: 'testing' stamp: 'StephaneDucasse 12/18/2009 11:57'!isResumable	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OutOfMemory class	instanceVariableNames: ''!Error subclass: #LimitesIncorrectos	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!